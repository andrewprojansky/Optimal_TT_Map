#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Op_TT_Ent.py
---------------------------------------------------------------------
Code for generating arbitrary optimal ternary trees, and checking if the map
of 2n majoranas from 2n+1 anticommuting paulis to the JW majoranas entangles 
the vacuum or not 

by Andrew Projansky
Last Edited 5/2/23

"""

import numpy as np
from numpy import linalg as LA
import random
import qiskit
from quimb import ptr

mult_dict = {'XX': ('I', 1), 'YY': ('I', 1), 'ZZ': ('I', 1), 'XY': ('Z', 1j), 
             'XZ': ('Y', -1j), 'YX': ('Z', -1j), 'YZ': ('X', 1j), 
             'ZX': ('Y', 1j), 'ZY': ('X', -1j), 'XI': ('X', 1),'YI': ('Y', 1),
             'ZI': ('Z', 1), 'IX': ('X', 1), 'IY': ('Y', 1), 'IZ': ('Z', 1),
             'II': ('I', 1)}

def l3(n):
    
    return np.log2(n)/np.log2(3)

def Gen_Tree(n):
    """
    Generates random optimal weight ternary tree encoding on n qubits. 
    Avoids generating actual trees, rather generates effects on trees. 
    At each depth d, chooses an ordering of 3^d leaves to append the 
    paulis too, while adding an identity to all other leaves. At any 
    moment list are either size 3 or size 1, 1 if X,Y,Z wasn't added yet. 

    Parameters
    ----------
    n : int
        number of qubits

    Returns
    -------
    flat_MS : 
        flattened list of all majoranas generated by tree

    """
    
    Ms = [['X'], ['Y'], ['Z']]
    Ps = ['X', 'Y', 'Z']
    depth =int(np.ceil(l3(2*n+1)))
    for i in range(1, depth):
        Ms = list(np.array(Ms).reshape(3**i, 1))
        inds = np.random.permutation(np.arange(0,3**i, 1))
        for sp in inds:
            if len(Ms[0][0]) < n:
                d_inds = list(inds)
                d_inds.remove(sp)
                Ms[sp] = [Ms[sp][0] + sig for sig in Ps]
                for nind in d_inds:
                    Ms[nind] = [p + 'I' for p in Ms[nind]]
    flat_MS = []
    for l in Ms:
        for j in l:
            flat_MS.append(j)
    return flat_MS   
    
def multiply(P1,P2,n):
    """
    Multiplies two pauli strings together by multplying element by element

    Parameters
    ----------
    P1 : string
        first pauli
    P2 : string
        second pauli 
    n : int
        number of qubits

    Returns
    -------
    stab : list
        pauli element with associated sign

    """
    
    stab = ['', 1]
    for l in range(n):
        p1 = P1[l]
        p2 = P2[l]
        stab[0] = stab[0] + mult_dict[p1+p2][0]
        stab[1] = stab[1] * mult_dict[p1+p2][1]
    return stab

def format_dict(Stab, Destab):
    """
    Formats stabilizer dictionary to be taken in by Qiskit

    Parameters
    ----------
    Stab : list
        list of tuples of stabilizers
    Destab : list
        list of tuples of destabilizers

    Returns
    -------
    s_dict : dict
        dictionary of stabilizers and destabilizers for qiskit

    """
    
    Sl = []
    Dl = []
    for stab in Stab:
        if stab[1] < 0:
            Sl.append('-'+stab[0])
        else:
            Sl.append('+'+stab[0])
    for stab in Destab:
        if stab[1] < 0:
            Dl.append('-'+stab[0])
        else:
            Dl.append('+'+stab[0])
    s_dict = {'stabilizer': Sl, 'destabilizer': Dl}
    return s_dict
        

def Stab_Destab(n, Ms):
    """
    generates stabilizer and destablilizer groups based on arbitrary 
    products of paulis 

    Parameters
    ----------
    n : int
        number of qubits
    Ms : list
        list of 2n+1 mutually anticommuting paulis

    Returns
    -------
    s_dict: dict
        dictionary of stabilizers to be (possibly) used in Qiskit

    """
    Stab = []
    Destab = []
    for j in range(n):
        P1 = Ms[2*j]
        P2 = Ms[2*j+1]
        stab = multiply(P1,P2,n)
        stab[1] = np.real(stab[1] * 1j)
        Stab.append(stab)
    for k in range(n):
        c = ['I'*n, 1]
        for m in range(k):
            ph = c[1]
            c = multiply(c[0], Stab[m][0], n); c[1] = c[1]*ph * Stab[m][1]
        P1 = Ms[2*k]
        P2 = c[0]; ph = c[1]
        destab = multiply(P1, P2, n)
        destab[1] = np.real(destab[1] * ph)
        Destab.append(destab)

    s_dict = format_dict(Stab, Destab)
    return s_dict, Ms


#The function below is not used but is left for an additional check 
def not_entangled(rho, n):
    """
    Checks every bipartition of the partition function to see if there is 
    entanglement. 
    
    Computationally inefficient, but can be used as a double check of the mps 
    below

    Parameters
    ----------
    rho : array
        density matrix of the full system
    n : int
        number of qubits

    Returns
    -------
    bool
        True if not entangled, false if entangled

    """
    
    for j in range(1, n):
        rho_red = ptr(rho, [2]*n, np.arange(0, j, 1))
        d, u = np.linalg.eig(rho_red)
        d = np.round(np.real(d),7)
        d = d[d != 0]
        if len(d) != 1:
            return False
    return True

def make_mps_like(psi, n):
    """
    Takes dense state to something like a matrix product state, except 
    the tensor at each site is flattened for a check later on in code. 
    
    If the state psi is a product state, the matrix product state
    should have bond dimension zero, and every flattened tensor should be of 
    size 2. I could've also kept things as full MPS and just iterated over
    bond dimension... 

    Parameters
    ----------
    psi : array
        state psi
    n : int
        number of qubits

    Returns
    -------
    T : list
        list of tensors

    """
    r = 1
    T = []
    psi_m = np.reshape(psi, (2*r, 2**(n-1)))
    for j in range(n-1):  
        u, d, vh = LA.svd(psi_m, full_matrices=False)
        u = np.round(u, 7)
        vh = np.round(vh, 7)
        d = np.round(np.real(d), 7)
        d = d[d != 0]
        r = len(d)
        u = u[:,np.arange(0,r,1)]
        vh = vh[np.arange(0,r,1),:]
        T.append(list(u.flatten()))
        psi_m = np.diag(d) @ vh
        psi_m = psi_m.reshape(2*r, 2**(n-2-j))
    T.append(list(psi_m.flatten()))
    return T
